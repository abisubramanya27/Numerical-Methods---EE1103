/*
QUIZ 2 - Version 1
The program completely analyses the Landau-Lifshitz equation that governs the dynamics of the a single magnetic moment in the presence of an applied magnetic field.
It uses different methods(forqard difference, fourth order range kutta, RK45), different stepsizes and different alpha (and other parameters) to generate the plots and thereby study the relaion between various parameters.
The program takes negative value of alpha as input and preserves the formula as given in the question
Answers and inferences are typed in the pdf file attached

Done by EE18B001 (Abishek. S), EE18B002 (Abhishek Shivram), EE18B006 (gayathri)
Created on 21st October 2018
*/


//START OF PROGRAM

#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define SEED 32767  //Seed value for the pseudo random number generator
#define pi 3.14159

//Global Declaration of the three rectangular components of M , H , stepsize , gama, alpha

//H is constant ans so are it's components Hx, Hy, Hz

//M_x, M_y, M_z are the intial components of M vector and it is not changed anywhere in the program

//Declaring these variables alone globally as they are needed in almost every function and passing as parameters only adds to the overhead cost and results in wastage of time and space (memory)

double M_x,M_y,M_z,Hx,Hy,Hz,stepsize = 0.001,gama,alpha;

//Possible stepsizes for which we may want to generate the plots - array of size 13

double stepsizes[] = {0.001,0.005,0.01,0.02,0.05,0.1,0.2,0.4,0.5,0.6,0.7,0.8,1};

//FUNCTION DECLARATIONS

//Function to calculate the derivative function : the last int parameter denotes 1 for derivative of Mx, 2 for that of My, 3 for that of Mz

double derivative(double, double, double, int);

//Function to calculate Mx,My,Mz at different time instants using forward difference method

void forward_diff();

//Function to calculate Mx,My,Mz at different time instants using fourth order range kutta method

void range_kutta();

//Function to calculate Mx,My,Mz at different time instants using fourth order RK-45 method

void RK_45();

//Function to calculate switching time for different values of alpha

void switching_time();

//Function to generate gnuplots for different stepsizes in forward difference method

void gnuplot_fd();

//Function to generate gnuplots for different stepsizes in fourth order range kutta method

void gnuplot_rk();

//Function to generate gnuplots for different stepsizes in RK 45 method

void gnuplot_RK45();

//Function to generate floating random number between 0 and 1

double frand();

//Function to implement BOX MULLER TRANSFORMATION (i.e)to return a random number following normal distribution from a uniformly distributed random number
//1st parameter : mean   2nd parameter : standard deviation

double box_muller(double, double);

//Function to add the error generated by box muller transformation, plot the noisy 3D graph obtained and calculate the error
//1st parameter : mean of normal distribution of random numbers  2nd parameter : standard deviation of normal distribution of random numbers

void noisify(double, double);

//Function to generate Mx vs time, My vs time, Mz vs time plots using RK-45 solver and stepsize 0.001

void M_t_plots();


//MAIN PART OF PROGRAM


int main(int argc,char **argv)
{
  //Check to make sure that arguments are passed as : Mx My Mz Hx Hy Hz gama alpha

  if(argc != 9)
  {
    printf("ARGUMENTS SHOULD BE OF THE FORM : %s Mx My Mz Hx Hy Hz gama alpha\n",argv[0]);
    exit(1);
  }

  srand(SEED);  //seed value is a constant so that every time the  program runs we get the same kind of plot with noise added

  M_x = atof(argv[1]);
  M_y = atof(argv[2]);
  M_z = atof(argv[3]);
  Hx = atof(argv[4]);
  Hy = atof(argv[5]);
  Hz = atof(argv[6]);
  gama = atof(argv[7]);
  alpha = atof(argv[8]);

  int input_mode = 7;
  double mean = 0, sigma = 0;    //sigma is standard deviation
  while (input_mode) {

    system("@cls||clear");
    printf("ENTER THE PROCESS THAT NEEDS TO BE CARRIED OUT : \n\n");
    printf("\t1.GENERATE 3D PLOTS USING FORWARD DIFFERENCE METHOD FOR DIFFERENT STEPSIZES\n");
    printf("\t2.GENERATE 3D PLOTS USING FOURTH ORDER RANGE KUTTA METHOD FOR DIFFERENT STEPSIZES\n");
    printf("\t3.GENERATE 3D PLOTS USING RK-45 METHOD FOR DIFFERENT STEPSIZES\n");
    printf("\t4.GENERATE SWITCHING TIME Vs ALPHA PLOT\n");
    printf("\t5.GENERATE 3D PLOT AFTER ADDING ERRORS FOLLOWING NORMAL DISTRIBUTION\n\t  AND CALCULATE ROOT MEAN ERROR AND CROSS CORRELATION\n");
    printf("\t6.GENERATE MX , My , Mz Vs t PLOTS USING RK-45 SOLVER AND STEPSIZE 0.001\n");
    printf("\t0.TO EXIT\n\n");
    scanf("%d",&input_mode);

    switch (input_mode) {
      case 1 :
         gnuplot_fd();
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();     //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 2 :
         gnuplot_rk();
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();     //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 3 :
         gnuplot_RK45();
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();     //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 4 :
         switching_time();
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();     //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 5 :
         printf("\n\nENTER THE MEAN AND STANDARD DEVIATION (sigma) OF NORMAL DISTRIBUTION OF THE RANDOM NUMBERS TO BE GENERATED\n\n");
         scanf("%lf%lf",&mean,&sigma);
         noisify(mean,sigma);
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();    //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 6 :
         M_t_plots();
         printf("\nSUCCESSFULLY DONE!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();     //One extra getchar() to strip out the new line character we entered after entering input
         getchar();
         break;
      case 0 :                  //If input_mode = 0 just break from the switch as the next iteration won't run anyway because input_mode = 0
         break;
         printf("\nQUITTING PROGRAM!!\n\nPRESS ANY KEY TO CONTINUE....");
         getchar();
      default :
         input_mode = 7;        //If typed any other number the loop just runs again as input_mode != 0 or any other proper number specified in the caselabels
         break;
    }

  }

  return 0;
}


//FUNCTION DEFINITIONS


double derivative(double Mx, double My, double Mz, int mode) {

  double der = 0;

  //For derivative of Mx

  if (mode == 1) {
    der = - gama * (- Hy * Mz + My * Hz) + alpha * (- Hx * Mz * Mz + Mx * Hz * Mz - Hx * My * My + Mx * Hy * My);
  }

  //For derivative of My

  else if (mode == 2) {
    der = - gama * (- Hz * Mx + Mz * Hx) + alpha * (- Hy * Mx * Mx + My * Hx * Mx - Hy * Mz * Mz + My * Hz * Mz);
  }

  //For derivative of Mz

  else if (mode == 3) {
    der = - gama * (- Hx * My + Mx * Hy) + alpha * (- Hz * My * My + Mz * Hy * My - Hz * Mx * Mx + Mx * Hx * Mz);
  }

  return der;

}

void forward_diff() {

  FILE *fptr_forward_diff ;

  //To check if file is opened successfully

  if (!(fptr_forward_diff = fopen("forward_diff.txt","w"))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //M is the magnitude of M vector

  double M = sqrt(M_x * M_x + M_y * M_y + M_z * M_z);

  //t denotes time. t_initial = 0

  double t = 0,Mx = M_x,My = M_y,Mz = M_z;

  //dx , dy , dz are dMx/dt , dMy/dt , dMz/dt respectively

  double dx,dy,dz;
  for (; t <= 200; t += stepsize) {

    fprintf(fptr_forward_diff,"%lf %lf %lf\n",Mx / M,My / M,Mz / M);

    dx = derivative(Mx,My,Mz,1);
    dy = derivative(Mx,My,Mz,2);
    dz = derivative(Mx,My,Mz,3);

    Mx += stepsize * dx;
    My += stepsize * dy;
    Mz += stepsize * dz;

    //NORMALISATION Step

    M = sqrt(Mx * Mx + My * My + Mz * Mz);

  }

  //Closing file

  fclose(fptr_forward_diff);

}

void range_kutta() {
  FILE *fptr_range_kutta ;

  //To check if file is opened successfully

  if (!(fptr_range_kutta = fopen("range_kutta.txt","w"))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //M is the magnitude of M vector

  double M = sqrt(M_x * M_x + M_y * M_y + M_z * M_z);

  //t denotes time. t_initial = 0

  double t = 0,Mx = M_x,My = M_y,Mz = M_z;

  //k1, k2, k3, k4 are the range kutta parameters. It is an array to store the parameters for Mx, My and Mz

  double k1[3], k2[3], k3[3], k4[3];
  for (; t <= 200; t += stepsize) {

    fprintf(fptr_range_kutta,"%lf %lf %lf\n",Mx / M,My / M,Mz / M);

    //Calculating the parameters for range kutta method (to calculate the weighted mean of derivatives)

    for (int i = 0; i < 3; i++) {
      k1[i] = stepsize * derivative(Mx,My,Mz,i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k2[i] = stepsize * derivative(Mx + (k1[0]/2),My + (k1[1]/2),Mz + (k1[2]/2),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k3[i] = stepsize * derivative(Mx + (k2[0]/2),My + (k2[1]/2),Mz + (k2[2]/2),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k4[i] = stepsize * derivative(Mx + k3[0],My + k3[1],Mz + k3[2],i + 1);
    }

    Mx += k1[0] / 6 + k2[0] / 3 + k3[0] / 3 + k4[0] / 6;
    My += k1[1] / 6 + k2[1] / 3 + k3[1] / 3 + k4[1] / 6;
    Mz += k1[2] / 6 + k2[2] / 3 + k3[2] / 3 + k4[2] / 6;

    //NORMALISATION Step

    M = sqrt(Mx * Mx + My * My + Mz * Mz);

  }

  //Closing file

  fclose(fptr_range_kutta);

}

void RK_45() {

  FILE *fptr_RK_45 ;

  //To check if file is opened successfully

  if (!(fptr_RK_45 = fopen("RK_45.txt","w"))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //M is the magnitude of M vector

  double M = sqrt(M_x * M_x + M_y * M_y + M_z * M_z);

  //t denotes time. t_initial = 0

  double t = 0,Mx = M_x,My = M_y,Mz = M_z;

  //k[1], k[2], k[3], k[4], k[5], k[6] are the RK-45 parameters
  //The 2nd index 0 : Mx 1 : My 2 : Mz

  double k[7][3];
  for (; t <= 200; t += stepsize) {

    fprintf(fptr_RK_45,"%lf %lf %lf\n",Mx / M,My / M,Mz / M);

    //Calculating the parameters for RK45 method (to calculate the weighted mean of derivatives)

    for (int i = 0; i < 3; i++) {
      k[1][i] = stepsize * derivative(Mx,My,Mz,i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[2][i] = stepsize * derivative(Mx + (k[1][0]/4),My + (k[1][1]/4),Mz + (k[1][2]/4),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[3][i] = stepsize * derivative(Mx + (k[2][0]*9/32) + (k[1][0]*3/32),My + (k[2][1]*9/32) + (k[1][1]*3/32),Mz + (k[2][2]*9/32) + (k[1][2]*3/32),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[4][i] = stepsize * derivative(Mx + (k[1][0]*1932/2197) - (k[2][0]*7200/2197) + (k[3][0]*7296/2197),My + (k[1][1]*1932/2197) - (k[2][1]*7200/2197) + (k[3][1]*7296/2197),Mz + (k[1][2]*1932/2197) - (k[2][2]*7200/2197) + (k[3][2]*7296/2197),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[5][i] = stepsize * derivative(Mx + (k[1][0]*439/216) - (k[2][0]*8) + (k[3][0]*3680/513) - (k[4][0]*845/4104),My + (k[1][1]*439/216) - (k[2][1]*8) + (k[3][1]*3680/513) - (k[4][1]*845/4104),Mz + (k[1][2]*439/216) - (k[2][2]*8) + (k[3][2]*3680/513) - (k[4][2]*845/4104),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[6][i] = stepsize * derivative(Mx - (k[1][0]*8/27) + (k[2][0]*2) - (k[3][0]*3544/2565) + (k[4][0]*1859/4104) - (k[5][0]*11/40),My - (k[1][1]*8/27) + (k[2][1]*2) - (k[3][1]*3544/2565) + (k[4][1]*1859/4104) - (k[5][1]*11/40),Mz - (k[1][2]*8/27) + (k[2][2]*2) - (k[3][2]*3544/2565) + (k[4][2]*1859/4104) - (k[5][2]*11/40),i + 1);
    }

    Mx += ((k[1][0]*25/216) + (k[3][0]*1408/2565) + (k[4][0]*2197/4101) - (k[5][0]/5));
    My += ((k[1][1]*25/216) + (k[3][1]*1408/2565) + (k[4][1]*2197/4101) - (k[5][1]/5));
    Mz += ((k[1][2]*25/216) + (k[3][2]*1408/2565) + (k[4][2]*2197/4101) - (k[5][2]/5));

    //NORMALISATION Step

    M = sqrt(Mx * Mx + My * My + Mz * Mz);

  }

  //Closing file

  fclose(fptr_RK_45);

}

void switching_time() {

  FILE *fptr_switch_time ;

  //To check if file is opened successfully

  if (!(fptr_switch_time = fopen("switch_time.txt","w"))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //t denotes switching time
  //Global variable alpha alone needs to be changed in this function as it is the with global value of alpha the derivative function works, and checked that no error occurs due to it
  //alpha_i is the initial global value of alpha

  double t = 0, alpha_i = alpha, Mx = M_x, My = M_y, Mz = M_z;

  //k[1], k[2], k[3], k[4], k[5], k[6] are the RK-45 parameters
  //The 2nd index 0 : Mx 1 : My 2 : Mz

  double k[7][3];
  for (alpha = -pow(10,-4); alpha >= -1; alpha += (- 1 + pow(10,-4))/10 ) {   //Varying alpha between -1 and -10^(-4) with 10 points in between
    t = 0;
    while (Mx < 0) {
      t += stepsize;
      //Calculating the parameters for RK45 method (to calculate the weighted mean of derivatives)

      for (int i = 0; i < 3; i++) {
        k[1][i] = stepsize * derivative(Mx,My,Mz,i + 1);
      }

      for (int i = 0; i < 3; i++) {
        k[2][i] = stepsize * derivative(Mx + (k[1][0]/4),My + (k[1][1]/4),Mz + (k[1][2]/4),i + 1);
      }

      for (int i = 0; i < 3; i++) {
        k[3][i] = stepsize * derivative(Mx + (k[2][0]*9/32) + (k[1][0]*3/32),My + (k[2][1]*9/32) + (k[1][1]*3/32),Mz + (k[2][2]*9/32) + (k[1][2]*3/32),i + 1);
      }

      for (int i = 0; i < 3; i++) {
        k[4][i] = stepsize * derivative(Mx + (k[1][0]*1932/2197) - (k[2][0]*7200/2197) + (k[3][0]*7296/2197),My + (k[1][1]*1932/2197) - (k[2][1]*7200/2197) + (k[3][1]*7296/2197),Mz + (k[1][2]*1932/2197) - (k[2][2]*7200/2197) + (k[3][2]*7296/2197),i + 1);
      }

      for (int i = 0; i < 3; i++) {
        k[5][i] = stepsize * derivative(Mx + (k[1][0]*439/216) - (k[2][0]*8) + (k[3][0]*3680/513) - (k[4][0]*845/4104),My + (k[1][1]*439/216) - (k[2][1]*8) + (k[3][1]*3680/513) - (k[4][1]*845/4104),Mz + (k[1][2]*439/216) - (k[2][2]*8) + (k[3][2]*3680/513) - (k[4][2]*845/4104),i + 1);
      }

      for (int i = 0; i < 3; i++) {
        k[6][i] = stepsize * derivative(Mx - (k[1][0]*8/27) + (k[2][0]*2) - (k[3][0]*3544/2565) + (k[4][0]*1859/4104) - (k[5][0]*11/40),My - (k[1][1]*8/27) + (k[2][1]*2) - (k[3][1]*3544/2565) + (k[4][1]*1859/4104) - (k[5][1]*11/40),Mz - (k[1][2]*8/27) + (k[2][2]*2) - (k[3][2]*3544/2565) + (k[4][2]*1859/4104) - (k[5][2]*11/40),i + 1);
      }

      Mx += ((k[1][0]*25/216) + (k[3][0]*1408/2565) + (k[4][0]*2197/4101) - (k[5][0]/5));
      My += ((k[1][1]*25/216) + (k[3][1]*1408/2565) + (k[4][1]*2197/4101) - (k[5][1]/5));
      Mz += ((k[1][2]*25/216) + (k[3][2]*1408/2565) + (k[4][2]*2197/4101) - (k[5][2]/5));
    }
    fprintf(fptr_switch_time,"%lf %lf\n",log10(fabs(alpha)),t);   //Plotting Switching time vs log10(fabs(alpha)) - fabs because alpha is negative as per the formula given
  }

  //Setting alpha back to it's initial value

  alpha = alpha_i;

  //Closing file

  fclose(fptr_switch_time);

  //GNUPLOT PART

  FILE *file_gnu_switch_time = fopen("switch_time.gp","w");    //Writing the gnuplot commands to a gnuplot script file
  fprintf(file_gnu_switch_time,"set term png\nset xlabel \"alpha\" textcolor lt 2\nset ylabel \"switching time\" textcolor lt 4\n");
  fprintf(file_gnu_switch_time,"set output \"switch_time.png\"\np \"switch_time.txt\" using 1:2 title \"switching-time-t vs log10(alpha)\" lc 3 with lines\n");
  fclose(file_gnu_switch_time);      //Closing the gnuplot script file so that we can execute those commands
  system("gnuplot -p 'switch_time.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  remove("switch_time.txt");
  remove("switch_time.gp");

}



void gnuplot_fd() {

  FILE *file_gnu_fd;
  for (int i = 0; i < 13; i++) {

    file_gnu_fd = fopen("fd.gp","w");    //Writing the gnuplot commands to a gnuplot script file
    fprintf(file_gnu_fd,"set term png\nset view equal xyz\nset xlabel \"M_x\" textcolor lt 2\nset ylabel \"M_y\" textcolor lt 4\nset zlabel \"M_z\" textcolor lt 3\n");
    stepsize = stepsizes[i];
    forward_diff();
    fprintf(file_gnu_fd,"set output \"fd_%.3lf.png\"\nsp \"forward_diff.txt\" u 1:2:3 title \"forward-difference-stepsize-%.3lf\" lc 2 with lines\n",stepsizes[i],stepsizes[i]);
    fclose(file_gnu_fd);     //Closing the gnuplot script file so that we can execute those commands
    system("gnuplot -p 'fd.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  }

  stepsize = 0.001;
  remove("forward_diff.txt");
  remove("fd.gp");

}

void gnuplot_rk() {

  FILE *file_gnu_rk;
  for (int i = 0; i < 13; i++) {

    file_gnu_rk = fopen("rk.gp","w");     //Writing the gnuplot commands to a gnuplot script file
    fprintf(file_gnu_rk,"set term png\nset view equal xyz\nset xlabel \"M_x\" textcolor lt 2\nset ylabel \"M_y\" textcolor lt 4\nset zlabel \"M_z\" textcolor lt 3\n");
    stepsize = stepsizes[i];
    range_kutta();
    fprintf(file_gnu_rk,"set output \"rk_%.3lf.png\"\nsp \"range_kutta.txt\" u 1:2:3 title \"range-kutta-stepsize-%.3lf\" lc 4 with lines\n",stepsizes[i],stepsizes[i]);
    fclose(file_gnu_rk);      //Closing the gnuplot script file so that we can execute those commands
    system("gnuplot -p 'rk.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  }

  stepsize = 0.001;
  remove("range_kutta.txt");
  remove("rk.gp");

}

void gnuplot_RK45() {

  FILE *file_gnu_RK45;
  for (int i = 0; i < 13; i++) {

    file_gnu_RK45 = fopen("RK45.gp","w");     //Writing the gnuplot commands to a gnuplot script file
    fprintf(file_gnu_RK45,"set term png\nset view equal xyz\nset xlabel \"M_x\" textcolor lt 2\nset ylabel \"M_y\" textcolor lt 4\nset zlabel \"M_z\" textcolor lt 3\n");
    stepsize = stepsizes[i];
    RK_45();
    fprintf(file_gnu_RK45,"set output \"RK45_%.3lf.png\"\nsp \"RK_45.txt\" using 1:2:3 title \"RK-45-stepsize-%.3lf\" lc 3 with lines\n",stepsizes[i],stepsizes[i]);
    fclose(file_gnu_RK45);      //Closing the gnuplot script file so that we can execute those commands
    system("gnuplot -p 'RK45.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  }

  stepsize = 0.001;
  remove("RK_45.txt");
  remove("RK45.gp");

}

void M_t_plots(){
  FILE *fptr_Mx, *fptr_My, *fptr_Mz;

  //To check if files are opened successfully

  if (!(fptr_Mx = fopen("Mx_vs_t.txt","w")) || !(fptr_My = fopen("My_vs_t.txt","w")) || !(fptr_Mz = fopen("Mz_vs_t.txt","w"))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //M is the magnitude of M vector

  double M = sqrt(M_x * M_x + M_y * M_y + M_z * M_z);

  //t denotes time. t_initial = 0

  double t = 0,Mx = M_x,My = M_y,Mz = M_z;

  //k[1], k[2], k[3], k[4], k[5], k[6] are the RK-45 parameters
  //The 2nd index 0 : Mx 1 : My 2 : Mz

  double k[7][3];
  for (; t <= 200; t += stepsize) {

    fprintf(fptr_Mx,"%lf %lf\n",t,Mx / M);
    fprintf(fptr_My,"%lf %lf\n",t,My / M);
    fprintf(fptr_Mz,"%lf %lf\n",t,Mz / M);

    //Calculating the parameters for RK45 method (to calculate the weighted mean of derivatives)

    for (int i = 0; i < 3; i++) {
      k[1][i] = stepsize * derivative(Mx,My,Mz,i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[2][i] = stepsize * derivative(Mx + (k[1][0]/4),My + (k[1][1]/4),Mz + (k[1][2]/4),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[3][i] = stepsize * derivative(Mx + (k[2][0]*9/32) + (k[1][0]*3/32),My + (k[2][1]*9/32) + (k[1][1]*3/32),Mz + (k[2][2]*9/32) + (k[1][2]*3/32),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[4][i] = stepsize * derivative(Mx + (k[1][0]*1932/2197) - (k[2][0]*7200/2197) + (k[3][0]*7296/2197),My + (k[1][1]*1932/2197) - (k[2][1]*7200/2197) + (k[3][1]*7296/2197),Mz + (k[1][2]*1932/2197) - (k[2][2]*7200/2197) + (k[3][2]*7296/2197),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[5][i] = stepsize * derivative(Mx + (k[1][0]*439/216) - (k[2][0]*8) + (k[3][0]*3680/513) - (k[4][0]*845/4104),My + (k[1][1]*439/216) - (k[2][1]*8) + (k[3][1]*3680/513) - (k[4][1]*845/4104),Mz + (k[1][2]*439/216) - (k[2][2]*8) + (k[3][2]*3680/513) - (k[4][2]*845/4104),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[6][i] = stepsize * derivative(Mx - (k[1][0]*8/27) + (k[2][0]*2) - (k[3][0]*3544/2565) + (k[4][0]*1859/4104) - (k[5][0]*11/40),My - (k[1][1]*8/27) + (k[2][1]*2) - (k[3][1]*3544/2565) + (k[4][1]*1859/4104) - (k[5][1]*11/40),Mz - (k[1][2]*8/27) + (k[2][2]*2) - (k[3][2]*3544/2565) + (k[4][2]*1859/4104) - (k[5][2]*11/40),i + 1);
    }

    Mx += ((k[1][0]*25/216) + (k[3][0]*1408/2565) + (k[4][0]*2197/4101) - (k[5][0]/5));
    My += ((k[1][1]*25/216) + (k[3][1]*1408/2565) + (k[4][1]*2197/4101) - (k[5][1]/5));
    Mz += ((k[1][2]*25/216) + (k[3][2]*1408/2565) + (k[4][2]*2197/4101) - (k[5][2]/5));

    //NORMALISATION Step

    M = sqrt(Mx * Mx + My * My + Mz * Mz);

  }

  //Closing files

  fclose(fptr_Mx);
  fclose(fptr_My);
  fclose(fptr_Mz);

  //GNUPLOT PART

  FILE *file_gnu_M = fopen("M_vs_t.gp","w");    //Writing the gnuplot commands to a gnuplot script file
  fprintf(file_gnu_M,"set term png\nset xlabel \"Mx\" textcolor lt 2\nset ylabel \"time\" textcolor lt 4\n");
  fprintf(file_gnu_M,"set output \"Mx_vs_t.png\"\np \"Mx_vs_t.txt\" using 1:2 title \"Mx vs time\" lc 3 with lines\n");
  fprintf(file_gnu_M,"set term png\nset xlabel \"My\" textcolor lt 2\nset ylabel \"time\" textcolor lt 4\n");
  fprintf(file_gnu_M,"set output \"My_vs_t.png\"\np \"My_vs_t.txt\" using 1:2 title \"My vs time\" lc 3 with lines\n");
  fprintf(file_gnu_M,"set term png\nset xlabel \"Mz\" textcolor lt 2\nset ylabel \"time\" textcolor lt 4\n");
  fprintf(file_gnu_M,"set output \"Mz_vs_t.png\"\np \"Mz_vs_t.txt\" using 1:2 title \"Mz vs time\" lc 3 with lines\n");
  fclose(file_gnu_M);      //Closing the gnuplot script file so that we can execute those commands
  system("gnuplot -p 'M_vs_t.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  remove("Mx_vs_t.txt");
  remove("My_vs_t.txt");
  remove("Mz_vs_t.txt");
  remove("M_vs_t.gp");
}

double frand() {

  //Generates random number between -1 and +1

  double random = 2 * (double)rand() / RAND_MAX - 1;
  return random;

}

double box_muller(double mean, double sigma) {
  //sigma square is variance, sigma is standard deviation

  double x1,x2,y1,r;
  static double y2;
  static int y2_used_prev = 1;

  //y2_used_prev will have 0 if y2 is returned else 1. There will be two random numbers generated when we do the box muller transform once.
  //One will be returned, the other can be returned the next time the fucntion is called. Hence using static variable to return it the next time.

  if (!y2_used_prev) {
    y2_used_prev = 1;
    return sigma * y2 + mean;
  }
  else {
    double r;
    do{
      x1 = frand();
      x2 = frand();
      r = x1*x1 + x2*x2;  //r will be between 0 and 1
    }while(r == 0 || r > 1);
    y1 = sqrt(-2 * log(r)) * x1;
    y2 = sqrt(-2 * log(r)) * x2;
    y2_used_prev = 0;
    return sigma * y1 + mean;
  }

}

void noisify(double mean, double sigma) {

  FILE *fptr_noisified_RK45, *fptr_RK45;

  RK_45();

  //To check if file is opened successfully

  if (!((fptr_noisified_RK45 = fopen("noisified_RK45.txt","w")) && (fptr_RK45 = fopen("RK_45.txt","r")))) {

    printf("ERROR OPENING FILE!!\n");
    exit(1);

  }

  //M is the magnitude of M vector

  double M = sqrt(M_x * M_x + M_y * M_y + M_z * M_z);

  //t denotes time. t_initial = 0
  //Mx,My,Mz are added with noise. Mx_w,My_w,Mz_w are the respective calues without noise

  double t = 0,Mx = M_x,My = M_y,Mz = M_z,Mx_w = M_x,My_w = M_y,Mz_w = M_z;

  //k[1], k[2], k[3], k[4], k[5], k[6] are the RK-45 parameters
  //The 2nd index 0 : Mx 1 : My 2 : Mz

  double k[7][3];
  double sqsum_error = 0;  //To calculate the sum of squares of errors for calculating root mean error

  //sum_pdt_noise_original is for calculating ∑ (Mx * M1 + My * M2 + Mz * M3)
  //sqsum_noise_M is for calculating ∑ (Mx * Mx + My * My + Mz * Mz)
  //sqsum_org_M is for calculating ∑ (M1 * M1 + M2 * M2 + M3 * M3)

  double sum_pdt_noise_original = 0, sqsum_noise_M = 0, sqsum_org_M = 0;   //These terms are used to calculate the correlation between the noisy plot and original plot (without noise)
  double M1,M2,M3;  //Input of the three (x,y,z) components of M from original RK_45.txt file in which data has no added noise
  for (; t <= 200; t += stepsize) {

    //Adding noise to the generated value (point)

    Mx += box_muller(mean, sigma);
    My += box_muller(mean, sigma);
    Mz += box_muller(mean, sigma);

    fprintf(fptr_noisified_RK45,"%lf %lf %lf\n",Mx_w / M,My_w / M,Mz_w / M);
    fscanf(fptr_RK45,"%lf %lf %lf",&M1,&M2,&M3);
    sqsum_error += pow((Mx_w/M) - M1,2) + pow((My_w/M) - M2,2) + pow((Mz_w/M) - M3,2);
    sum_pdt_noise_original += (Mx_w * M1 + My_w * M2 + Mz_w * M3);
    sqsum_noise_M += (Mx_w * Mx_w + My_w * My_w + Mz_w * Mz_w);
    sqsum_org_M += (M1 * M1 + M2 * M2 + M3 * M3);

    //Calculating the parameters for range kutta method (to calculate the weighted mean of derivatives)

    for (int i = 1; i < 7; i++) {
      k[1][i] = stepsize * derivative(Mx,My,Mz,i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[2][i] = stepsize * derivative(Mx + (k[1][0]/4),My + (k[1][1]/4),Mz + (k[1][2]/4),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[3][i] = stepsize * derivative(Mx + (k[2][0]*9/32) + (k[1][0]*3/32),My + (k[2][1]*9/32) + (k[1][1]*3/32),Mz + (k[2][2]*9/32) + (k[1][2]*3/32),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[4][i] = stepsize * derivative(Mx + (k[1][0]*1932/2197) - (k[2][0]*7200/2197) + (k[3][0]*7296/2197),My + (k[1][1]*1932/2197) - (k[2][1]*7200/2197) + (k[3][1]*7296/2197),Mz + (k[1][2]*1932/2197) - (k[2][2]*7200/2197) + (k[3][2]*7296/2197),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[5][i] = stepsize * derivative(Mx + (k[1][0]*439/216) - (k[2][0]*8) + (k[3][0]*3680/513) - (k[4][0]*845/4104),My + (k[1][1]*439/216) - (k[2][1]*8) + (k[3][1]*3680/513) - (k[4][1]*845/4104),Mz + (k[1][2]*439/216) - (k[2][2]*8) + (k[3][2]*3680/513) - (k[4][2]*845/4104),i + 1);
    }

    for (int i = 0; i < 3; i++) {
      k[6][i] = stepsize * derivative(Mx - (k[1][0]*8/27) + (k[2][0]*2) - (k[3][0]*3544/2565) + (k[4][0]*1859/4104) - (k[5][0]*11/40),My - (k[1][1]*8/27) + (k[2][1]*2) - (k[3][1]*3544/2565) + (k[4][1]*1859/4104) - (k[5][1]*11/40),Mz - (k[1][2]*8/27) + (k[2][2]*2) - (k[3][2]*3544/2565) + (k[4][2]*1859/4104) - (k[5][2]*11/40),i + 1);
    }

    //The dMi must be added to original Mi to get Mi+1 not to Mi with noise

    Mx = Mx_w + ((k[1][0]*25/216) + (k[3][0]*1408/2565) + (k[4][0]*2197/4101) - (k[5][0]/5));
    My = My_w + ((k[1][1]*25/216) + (k[3][1]*1408/2565) + (k[4][1]*2197/4101) - (k[5][1]/5));
    Mz = Mz_w + ((k[1][2]*25/216) + (k[3][2]*1408/2565) + (k[4][2]*2197/4101) - (k[5][2]/5));

    //Mi+1 = f(Mi + ni) * stepsize, where f(x) is dx/dt
    //This means the Mi is added with noise and the noisified quantities are used to calculate the derivatives thus adding noise to the original wave for the next point

    Mx_w = Mx;
    My_w = My;
    Mz_w = Mz;

    //NORMALISATION Step

    M = sqrt(Mx_w * Mx_w + My_w * My_w + Mz_w * Mz_w);

  }

  //Closing files

  fclose(fptr_noisified_RK45);
  fclose(fptr_RK45);

  /*
  The cross correlation error is :
       sum_pdt_noise_original / sqrt(sqsum_org_M * sqsum_noise_M)
  The root mean error is :
       sqrt(sqsum_error / N)   where N = (200 / stepsize);
  */

  printf("\nThe correlation is : %lf\n",sum_pdt_noise_original / sqrt(sqsum_org_M * sqsum_noise_M));
  printf("\nThe root mean error is : %lf\n",sqrt(sqsum_error / (200 / stepsize)));

  FILE *file_gnu_noise_RK45 = fopen("noisified_RK45.gp","w");    //Writing the gnuplot commands to a gnuplot script file
  fprintf(file_gnu_noise_RK45,"set term png\nset view equal xyz\nset xlabel \"M_x\" textcolor lt 2\nset ylabel \"M_y\" textcolor lt 4\nset zlabel \"M_z\" textcolor lt 3\n");
  fprintf(file_gnu_noise_RK45,"set output \"noisified_RK45_%.3lf.png\"\nsp \"noisified_RK45.txt\" using 1:2:3 title \"noisified-RK-45-sigma-%.3lf\" lc 3 with lines\n",sigma,sigma);
  fclose(file_gnu_noise_RK45);      //Closing the gnuplot script file so that we can execute those commands
  system("gnuplot -p 'noisified_RK45.gp'");    //Using system function to run the commands in the gnuplot script file and generate the plot from the c program

  remove("noisified_RK45.txt");
  remove("noisified_RK45.gp");
  remove("RK_45.txt");

}

//END OF PROGRAM

/*
COMMANDS TO RUN THE CODE (IN TERMINAL) :

To compile the program
gcc quiz2.c -lm

To run the program
./a.out -0.99 0 0 1 0.01 0 1 -0.05

*/
